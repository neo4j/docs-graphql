[[mutations-update]]
:description: This page describes how to update nodes through mutations.
= `update`

Using these type definitions:

[source, graphql, indent=0]
----
type Post {
    id: ID! @id
    content: String!
    creator: User! @relationship(type: "HAS_POST", direction: IN)
}

type User {
    id: ID! @id
    name: String
    posts: [Post!]! @relationship(type: "HAS_POST", direction: OUT)
}
----

These `update` mutations and response types should be generated:

[source, graphql, indent=0]
----
type UpdatePostsMutationResponse {
    posts: [Post!]!
}

type UpdateUsersMutationResponse {
    users: [User!]!
}

type Mutation {
    updatePosts(
        where: PostWhere
        update: PostUpdateInput
        connect: PostConnectInput
        disconnect: PostDisconnectInput
        create: PostCreateInput
        delete: PostDeleteInput
    ): UpdatePostsMutationResponse!
    updateUsers(
        where: UserWhere
        update: UserUpdateInput
        connect: UserConnectInput
        disconnect: UserDisconnectInput
        create: UserCreateInput
        delete: UserDeleteInput
    ): UpdateUsersMutationResponse!
}
----

[NOTE]
====
The `id` field cannot be updated as the xref::reference/directives/autogeneration.adoc#type-definitions-autogeneration-id[`@id`] directive has been used.
====

== Single `update`

The content of a `Post` can be updated by executing the following GraphQL statement:

[source, graphql, indent=0]
----
mutation {
    updatePosts(
        where: {
            id: "892CC104-A228-4BB3-8640-6ADC9F2C2A5F"
        }
        update: {
            content: "Some new content for this Post!"
        }
    ) {
        posts {
            content
        }
    }
}
----

This should update the post by adding the sentence "Some new content for this Post!".

== Nested `create` using `update`

Instead of creating a `Post` with the `create` mutation and then connecting it to a `User`, you can update a `User` and `create` a `Post` as part of the mutation:

[source, graphql, indent=0]
----
mutation {
    updateUsers(
        where: { name: "John Doe" }
        create: {
            posts: [
                { node: { content: "An interesting way of adding a new Post!" } }
            ]
        }
    ) {
        users {
            id
            name
            posts {
                content
            }
        }
    }
}
----

== `connectOrCreate` relationships

Consider the example provided in the xref:mutations/create.adoc#_connectorcreate_relationships[`create`] page:

[source, graphql, indent=0]
----
mutation {
  createActors(input: {
    name: "Tom Hanks",
    movies: {
      connectOrCreate: {
        where: { node: { id: "1234" } }
        onCreate: { node: { title: "Forrest Gump" } }
      }
    }
  }) {
    info {
      nodesCreated
    }
  }
}
----

For `update` operations, `connectOrCreate` can also be used as a top-level input for an equivalent operation:

[source, graphql, indent=0]
----
mutation {
  updateActors(
      connectOrCreate: {
        movies: {
            where: { node: { id: "1234" } }
            onCreate: { node: { title: "Forrest Gump" } }
        }
      },
      where: { name: "Tom Hanks" }
  ) {
    info {
      nodesCreated
    }
  }
}
----

== Array methods

Array methods allow us to modify existing property arrays in Update mutations within these entities:

* `Node`
* `Nested Nodes`
* `Relationship properties`
* `Interfaces`

The following operators are available:

* `_POP`
* `_PUSH`

The POP operator expects a single Int value as input

The PUSH operator conforms to the type of input defined in the type definition.

=== Examples

==== Array pop
Suppose we have the following type definition, a Movie with a property array called tags:

[source, graphql, indent=0]
----
type Movie {
    title: String
    tags: [String]
}
----

We can pop from this `tags` property array.

Before: `['a', 'b', 'c']`

After: `['a', 'b']`


[source, graphql, indent=0]
----
mutation {
    updateMovies (update: { tags_POP: 1 }) {
        movies {
            title
            tags
        }
    }
}
----

Or, for more than one property from the array:

Before: `['a', 'b', 'c']`

After: `['a']`

[source, graphql, indent=0]
----
mutation {
    updateMovies (update: { tags_POP: 2 }) {
        movies {
            title
            tags
        }
    }
}
----

Similarly, you can have multiple array property fields and update them in the same query:


[source, graphql, indent=0]
----
type Movie {
    title: String
    tags: [String]
    moreTags: [String]
}
----

We can pop from both the `tags` and `moreTags` property arrays.


Before: 
```
    tags: ['a', 'b', 'c']
    moreTags: ['x', 'y', 'z']
```

After:
```
    tags: ['a', 'b']
    moreTags: ['x']
```

[source, graphql, indent=0]
----
mutation {
    updateMovies (update: { tags_POP: 1, moreTags_POP: 2 }) {
        movies {
            title
            tags
            moreTags
        }
    }
}
----

==== Array push
Suppose we have the following type definition, a Movie with a property array called tags:

[source, graphql, indent=0]
----
type Movie {
    title: String
    tags: [String]
}
----

We can push to this `tags` property array.


Before: `['some tag']`

After: `['some tag', 'another tag']`

[source, graphql, indent=0]
----
mutation {
    updateMovies (update: { tags_PUSH: "another tag" }) {
        movies {
            title
            tags
        }
    }
}
----

Or push multiple elements in a single update:

Before: `['some tag']`

After: `['some tag', 'another tag', 'one more tag']`

[source, graphql, indent=0]
----
mutation {
    updateMovies (update: { tags_PUSH: ["another tag", "one more tag"] }) {
        movies {
            title
            tags
        }
    }
}
----

Similarly, you can have multiple array property fields and update them in the same query:

[source, graphql, indent=0]
----
type Movie {
    title: String
    tags: [String]
    moreTags: [String]
}
----

We can push to both the `tags` and `moreTags` property arrays.

Before:
```
    tags: ['some tag']
    moreTags: []
```

After:
```
    tags: ['some tag', 'another tag']
    moreTags ['a different tag']
```

[source, graphql, indent=0]
----
mutation {
    updateMovies (update: { tags_PUSH: "another tag", moreTags_PUSH: "a different tag" }) {
        movies {
            title
            tags
            moreTags
        }
    }
}
----

==== Array push and pop in one update

It is possible to perform both a push and pop operation in one Update mutation.

Suppose we have the following type definition, a Movie with a property array called tags:

[source, graphql, indent=0]
----
type Movie {
    title: String
    tags: [String]
    moreTags: [String]
}
----

We can then update both property arrays with either _POP or _PUSH operators.

Before:
```
    tags: ['some tag']
    moreTags: []
```

After:
```
    tags: []
    moreTags ['a different tag']
```

[source, graphql, indent=0]
----
mutation {
    updateMovies (update: { tags_POP: 1, moreTags_PUSH: "a different tag" }) {
        movies {
            title
            tags
            moreTags
        }
    }
}
----

[[mathematical-operators]]
== Mathematical operators

Mathematical operators are a handy way to update numerical fields based on their original values in a single DB transaction.

Specific operators are available on different numerical types (`Int`, `Float`, xref::reference/type-definitions/types.adoc#type-definitions-types-bigint[`BigInt`]).


Mathematical operators are supported in Update Mutations within these entities:

* `Node`
* `Nested Nodes`
* `Relationship properties`
* `Interfaces`

=== Int and BigInt operators
For `Int` and `BigInt` types, the following operators are available:

* `_DECREMENT`
* `_INCREMENT`

=== Float operators
For `Float` type, the following operators are available:

* `_ADD`
* `_SUBTRACT`
* `_MULTIPLY`
* `_DIVIDE`

=== Examples

==== The social platform schema
In this section, we use the following GraphQL schema:

[source, graphql, indent=0]
----
type Video {
  id: ID @id
  views: Int
  ownedBy: User @relationship(type: "OWN_VIDEO", properties: "OwnVideo", direction: IN)
}
type User {
  id: ID @id
  ownVideo: [Video!]! @relationship(type: "OWN_VIDEO", properties: "OwnVideo", direction: OUT)
}
interface OwnVideo @relationshipProperties {
  revenue: Float
}
----


==== Simple increment operation
Let's say that a user views a video, so we want to increment `viewersCount` for that video by 1.
[source, graphql, indent=0]
----
mutation incrementViewCountMutation {
  updateVideos(
    where: { id: "VideoID" }
    update: { views_INCREMENT: 1 }
  ) {
    videos {
      id
      views
    }
  }
}
----

==== Nested example
Now, let's say that the video platform wants to reward the user with 0.01 dollars for viewing the video.
To do that, we have to update the relationship property `revenue`.

[source, graphql, indent=0]
----
mutation addRevenueMutation {
  updateUsers(
    where: { id: "UserID" },
    update: { ownVideo: [{ update: { edge: { revenue_ADD: 0.01 } } }] }
  ) {
    users {
      id
      ownVideoConnection {
        edges {
          revenue
        }
      }
    }
  }
}
----

=== Optional fields
Operators remain available for optional fields, this means that if a mathematical operator has been used in a field not defined then a GraphQL error is raised.
