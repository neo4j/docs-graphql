[[mutations-create]]
:description: This page describes how to create nodes through mutations.
= `create`

Using the following type definitions:

[source, graphql, indent=0]
----
type Post {
    id: ID! @id
    content: String!
    creator: User! @relationship(type: "HAS_POST", direction: IN)
}

type User {
    id: ID! @id
    name: String
    posts: [Post!]! @relationship(type: "HAS_POST", direction: OUT)
}
----

These `create` mutations and response types should be generated:

[source, graphql, indent=0]
----
type CreatePostsMutationResponse {
    posts: [Post!]!
}

type CreateUsersMutationResponse {
    users: [User!]!
}

type Mutation {
    createPosts(input: [PostCreateInput!]!): CreatePostsMutationResponse!
    createUsers(input: [UsersCreateInput!]!): CreateUsersMutationResponse!
}
----

Note that the `CreateInput` types closely mirror the object type definitions.
This allows you to create not only the type in question, but to recurse down and perform further operations on related types in the same mutation.

[NOTE]
====
The `id` field is absent from both `create` input types as the xref::reference/directives/autogeneration.adoc#type-definitions-autogeneration-id[`@id`] directive has been used.
====

== Single `create`

A single `User` can be created by executing the following GraphQL statement:

[source, graphql, indent=0]
----
mutation {
    createUsers(input: [
        {
            name: "John Doe"
        }
    ]) {
        users {
            id
            name
        }
    }
}
----

This should create a `User` with name "John Doe", and that name plus the autogenerated ID should be returned.

== Nested `create`

A `User` and an initial `Post` can be created by executing the following:

[source, graphql, indent=0]
----
mutation {
    createUsers(input: [
        {
            name: "John Doe"
            posts: {
                create: [
                    {
                        node: {
                            content: "Hi, my name is John!"
                        }
                    }
                ]
            }
        }
    ]) {
        users {
            id
            name
            posts {
                id
                content
            }
        }
    }
}
----

This creates a `User` with name "John Doe" and an introductory post.
Both should be returned with their autogenerated IDs.

[NOTE]
====
You can perform similar and complementary actions by using the `update` mutation combined with `create`.
Read about xref:mutations/update.adoc#_connectorcreate_relationships[`update`] for more information.
====

== `connectOrCreate` relationships

If a related node has a `@unique` or `@id` directive defined, `connectOrCreate` can be used in a nested `create` to perform a `MERGE` operation on the related node.
This should create a new relationship and the related node if it doesn't exist yet.

Consider the following type definitions:

[source, graphql, indent=0]
----
type Actor {
    name: String!
    movies: [Movie!]! @relationship(type: "ACTED_IN", direction: OUT)
}

type Movie {
    title: String
    id: ID! @id
    actors: [Actor!]! @relationship(type: "ACTED_IN", direction: IN)
}
----

Because a movie ID is unique, `connectOrCreate` can be used in an `Actor` mutation to ensure the movie exists in the database before connecting. 
Note that only `@unique` or `@id` fields can be used in `where`:

[source, graphql, indent=0]
----
mutation {
  createActors(input: {
    name: "Tom Hanks",
    movies: {
      connectOrCreate: {
        where: { node: { id: "1234" } }
        onCreate: { node: { title: "Forrest Gump" } }
      }
    }
  }) {
    info {
      nodesCreated
    }
  }
}
----

This ensures that a movie with ID "1234" exists and is connected to `"Tom Hanks"`. 
If the movie does not exist, it will be created with the title `"Forrest Gump"`. 
However, if the movie with the given ID already exists, it will be connected to it, regardless of the title.

== Optimizing `create` operations

It is possible to use the Neo4jGraphQL library to create several nodes and relationships in a single mutation.
However, it is well known that performance issues are present in performing this task.
A solution has been implemented that doesn't require any changes from the user.
However, there are still several situations where this kind of optimization is not achievable.

=== Subscriptions enabled

No optimizations are available if a Subscription plugin it's being used.

=== `@populated_by`

No optimizations are available if a Node affected by the mutation has a field with the directive `@populated_by`.

=== `connect` and `connectOrCreate` operations

No optimizations are available if the GraphQL input contains the `connect` or `connectOrCreate` operation.